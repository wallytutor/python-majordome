# Diffusion in 1-D {#sec-diffusion-1d}

## Import toolbox

```{python}
# TODO: remove this after development
%load_ext autoreload
%autoreload 2
```

```{python}
from sympy import (
    Eq,
    symbols,
    expand,
    factor,
    solve,
    cancel,
    numer,
)
from diffusion import (
    FvmVars,
    CellVars,
    FaceVars,
    StandardProblem,
    harmonic_mean,
    diffusion_flux,
    get_fv_coefficients,
    tabulate_fv_coefs,
)
import diffusion
```

## Introductory Fickean diffusion

Assume a simple concentration-dependent diffusion in the absence of external driving forces; in this introduction we chose to *model* the diffusive flux through Fick's constitutive (first) law stated below, where $D$ is the diffusion coefficient that may depend on position $x$ and/or concentration $c$, *i.e.* $D\equiv{}D(x, c)$. It states that diffusive flux of an species has the composition gradient as a driver force; the negative sign indicates that diffusion occurs from high to low concentration regions.

$$
J=-D\dfrac{\partial{}c}{\partial{}x}
$$

We can anticipate here that this can be the case for simple diluted systems, but interactions between species must be considered in concentrated solutions, what is generalized by the *Irreversible Thermodynamics* by @Onsager1931 and @Onsager1931a. Here we emphasize again the word *model*: empirical observation has led scientists to *represent* reality through such an approximation; different models can be used for the same physics with their applicability limited to certain scenarios. Properly selecting an applicable model is the role of the researcher/engineer, what is outside our scope here; in what follows we will focus on *how to solve* balance equations for a given model.

Simply put, diffusion equation solves for a local mass balance; and mathematically, a local balance leads to a divergence operation. Following this idea, it can be shown that the time derivative of concentration $c$ at one location is given by the divergence - which collapses to the spatial derivative - of the negative of mass flux given by Fick's (first) law (or in general any other constitutive law/model describing the mass flux); sometimes this form is called Fick's second law in the literature. Given the possible nonlinearity introduced by diffusion coefficient $D$, the derivative in the right-hand side is not expanded. In Cartesian coordinate system, the governing diffusion equation in one dimension writes:

$$
\dfrac{\partial{}c}{\partial{}t}=
\dfrac{\partial{}}{\partial{}x}
\left(D\dfrac{\partial{}c}{\partial{}x}\right)
$$

This is the form of the diffusion equation that is discussed in what follows.

## Internal discretization

To solve the diffusion equation numerically, we employ the finite volume method (FVM). The first step to establish a FVM scheme consists of integrating the governing equation over a control volume $P$ from $w$ (west face) to $e$ (east face) and over a time interval from $0$ to $\tau$. The left-hand side is first integrated over time as it represents a *storage* term, meaning that it measures how much the average concentration changes in the control volume over the time-step. The right-hand side is a *flux* term, and using similar arguments its *natural* integration is performed over space. Also, the order of integration can be exchanged due to the smoothness assumptions considered here. For more details, please check @Patankar1980.

$$
\int_{w}^{e}\int_{0}^{\tau}
\dfrac{\partial{}c}{\partial{}t}dt\:dx=
\int_{0}^{\tau}\int_{w}^{e}
\dfrac{\partial{}}{\partial{}x}
\left(D\dfrac{\partial{}c}{\partial{}x}\right)dx\:dt
$$

This double integration allows us to convert the partial differential equation into a form suitable for numerical discretization. Evaluating the innermost integrals leads to:

$$
\int_{w}^{e}
\left(c_{P}-c_{P}^{0}\right)\:dx=
\int_{0}^{\tau}
\left[
    \left(D\dfrac{\partial{}c}{\partial{}x}\right)_{e}-
    \left(D\dfrac{\partial{}c}{\partial{}x}\right)_{w}
\right]
\:dt
$$

Here, $c_P^0$ and $c_P$ represent the concentration at the center of the control volume $P$ at times $0$ and $\tau$, respectively. A convention of not adding a superscript to time $\tau$ is adopted here, unless required by the context. The right-hand side represents the net flux into the control volume through its east and west faces. Assuming the concentration is uniform within each control volume and the fluxes are constant over the time interval, we obtain:

$$
\left(c_{P}-c_{P}^{0}\right)
\dfrac{\delta}{\tau}=
\left(D\dfrac{\partial{}c}{\partial{}x}\right)_{e}-
\left(D\dfrac{\partial{}c}{\partial{}x}\right)_{w}
$$

where $\delta$ is the width of the control volume. This equation represents a discrete time-step of the diffusion equation for a single control volume, where one still needs to specify a discretization of the gradients, *i.e.* how the fluxes are evaluated at a cell face. A simple introductory approach is to use forward differences, where the composition gradients are approximated as first differences between neighbors.

Below we compose this expression with help of [SymPy](https://docs.sympy.org/latest/index.html). Notice that when compositing the right-hand side `rhs` we multiply by -1 because we are integrating the negative of the fluxes.

```{=html}
<!--
\left(c_{P}-c_{P}^{0}\right)
\dfrac{\delta}{\tau}=
D_{e}\dfrac{c_{E}-c_{P}}{\delta}-
D_{w}\dfrac{c_{P}-c_{W}}{\delta}
-->
```

```{python}
J_w = diffusion_flux(FaceVars.D_w, CellVars.c_W, CellVars.c_P)
J_e = diffusion_flux(FaceVars.D_e, CellVars.c_P, CellVars.c_E)

lhs = (CellVars.c_P - CellVars.c_0) * FvmVars.delta / FvmVars.tau
rhs = -1 * (J_e - J_w)

eq = Eq(lhs - rhs, 0)
eq
```

Here, $c_E$ and $c_W$ are the concentrations at the eastern and western neighboring control volumes, respectively, and $D_e$ and $D_w$ are the effective diffusion coefficients at the east and west faces of the control volume. @Patankar1980 shows that the evaluation of these diffusion coefficients is not arbitrary and for conservation (here the continuity of flux across the interface) to be respected one must take the harmonic mean of neighboring cells:

$$
D_{k}=2\frac{D_{i}D_{j}}{D_{i}+D_{j}}
$$

A final step to get a linear form of the problem is multiplying both sides by $\tau/\delta$ and rearranging terms. This form clearly shows the contribution of each neighboring concentration to the rate of change at point P. The coefficient of $c_P$ is negative, representing the outflow from the central node, while the coefficients of $c_E$ and $c_W$ are positive, representing inflow from the neighboring nodes.

```{=html}
<!--
c_{P}-c_{P}^{0}=
\dfrac{\tau}{\delta^2}\left[
    D_{e}c_{E}-(D_{e}+D_{w})c_{P}+D_{w}c_{W}
\right]
-->
```

```{python}
eq = Eq(expand(eq.lhs * FvmVars.tau / FvmVars.delta), 0)
eq
```

Introducing dimensionless coefficients $\alpha_{k}$, the [Fourier number](https://en.wikipedia.org/wiki/Fourier_number) for mass transfer (more generally referred to as $\mathcal{Fo}_{m}$), we obtain the final discretized form. It represents the dimensionless diffusion number, which determines the stability and accuracy of the numerical scheme. The subscript $k$ refers to either the east ($e$) or west ($w$) face.

$$
\alpha_{k}=\dfrac{\tau{}D_{k}}{\delta^2}
$$

```{=html}
<!--
c_{P}-c_{P}^{0}=
\alpha_{e}c_{E}-(\alpha_{e}+\alpha_{w})c_{P}+\alpha_{w}c_{W}
-->
```

Performing the replacements with help of SymPy:

```{python}
eq = Eq(eq.lhs.subs(diffusion.SUBS_FOURIER), 0)
eq
```

Notice that so far nothing has been said with respect to the instant at which the right-hand side is evaluated. The obvious solution would be to take $c_{0}\equiv{}c_{P}^{0}$ as it is currently known, but for numerical stability reasons we will continue here with an implicit scheme so that all values other than $c_{0}$ are defined to be evaluated at time $\tau$, *i.e.* $c_{K}\equiv{}c_{K}^{\tau}$, in phase with the notation convention introduced above.

Because it is more convenient for symbolic manipulations with SymPy, the problem is currently writen as $F(c)=0$, *i.e.* all elements are on the left-hand side. Care must be taken to properly interpret the signs of the coefficients below.

```{python}
coefs = get_fv_coefficients(eq.lhs)
coefs
```

Because it is mor readable, a helper utility is provided to tabulate them:

```{python}
tabulate_fv_coefs(eq.lhs)
```

```{=html}
<!--
c_{P}^{\tau}-c_{P}^{0}=
\alpha_{e}^{\tau}c_{E}^{\tau}-
(\alpha_{e}^{\tau}+\alpha_{w}^{\tau})c_{P}^{\tau}+
\alpha_{w}^{\tau}c_{W}^{\tau}

Each cell in the triple has its coefficient and a more convenient form (for later programming its solution) is established by representing the equation as

A_{W}c_{W}^{\tau} + A_{P}c_{P}^{\tau} + A_{E}c_{E}^{\tau} = c_{P}^{0}

where

\begin{align*}
A_{P} &= 1 + \alpha_{e}^{\tau}+\alpha_{w}^{\tau}
\\[6pt]
A_{E} &= -\alpha_{e}^{\tau}
\\[6pt]
A_{W} &= -\alpha_{w}^{\tau}
\end{align*}
-->
```

## Boundary conditions

So far all we have derived are the internal balances of the system, we still lack proper boundary conditions. It should be evident by now that we have formulated a tridiagonal matrix for representing the 1-D system: there are 3 unknowns at step $\tau$ ($c_W$, $c_P$, and $c_E$) and a currently known *field* $c_0$.

In what follows we will workout the three families of boundary conditions: Dirichlet (type 1), Neumann (type 2), and the more general Robin (type 3). Following this sequence will create the required intuition for deriving the progressively more complex conditions. In practice, for diffusion in solids often only the implementation of Robin conditions is required, as it will be discussed later. Our goal at presenting types 1 and 2 is simply to introduce the tooling required for working out type 3 boundary condition; they will not be treated in full detail, leaving the full discussion for later.

The implementation of boundary conditions requires special treatment of the control volumes at the domain boundaries. The general form for a boundary control volume is:

$$
\left(c_{P}-c_{P}^{0}\right)
\dfrac{\delta}{\tau}=
\text{flux}_{\text{interior}} - \text{flux}_{\text{boundary}}
$$

It is worth here repeating the partial development derived above for an analogy:

$$
\left(c_{P}^{\tau}-c_{P}^{0}\right)
\dfrac{\delta}{\tau}=
D_{e}\dfrac{c_{E}-c_{P}}{\delta}-
D_{w}\dfrac{c_{P}-c_{W}}{\delta}
$$

Please, notice that from now on we make use of class `StandardProblem` for the end of representing a canonical discrete equation. It encodes the results obtained in the previous section and is also repeated below:

```{python}
StandardProblem.full_expression()
```

### Type 1 - Dirichlet

Let's start by the Dirichlet, or fixed concentration, boundary condition (type 1), for which the concentration at the boundary face is prescribed, *i.e.* $c_{\text{B}} = c_{\text{prescribed}}$. Notice that before using this we need to make a choice regarding the computational grid (mesh); you could have half-volumes on boundaries, fictitious volumes (sometimes called ghost cells), or immesed nodes over the boundary.

Partial control volumes on boundaries are not desirable as they introduce implementation complexities in code and lack conservation (especially in higher dimensions), see a discussion by @Maliska2004 (section 3.7) for details. In what follows we discuss immersed nodes and extended domains with _ghost_ cells. This last solution implies considerably more unknowns in 3-D problems, for which different variants of FVM will be discussed at a more advanced point.

::: {.callout-note title="Immersed boundary"}

Assume the last cell on _west_ boundary is indexed as $P$; over its _west_ boundary we find a node where prescribed composition $c_{B}$ is enforced - and the corresponding diffusion coefficient $D_{b}$. Notice that this node does not belong to the cell, nor represents a half-cell, but lies over its boundary. We start by computing the mass flux from the boundary node to the first cell center; this flux is computed using half-cell length $\delta/2$ for the derivative approximation.

```{python}
J_w = diffusion_flux(FaceVars.D_b, CellVars.c_P,
                     CellVars.c_B, delta=FvmVars.delta/2)
J_w
```

This expression of flux is used as replacement for the _west_ boundary in the full equation:

```{python}
eq = StandardProblem.full_expression(J_w=J_w, subs_fourier=True)
eq
```

The coefficients for the first row of the matrix problem are summarized below:

```{python}
tabulate_fv_coefs(eq.lhs)
```

:::

The immersed boundary approach presented above is simple. Nonetheless, it requires a different calculation of boundary nodes with respect to the volume, but that comes with the advantage that no additional equation has been added to the system. Let's now explore the extended domain alternative.

As above, assume the last cell on _west_ boundary is indexed as $P$. Consider another _ghost_ cell to its left being denoted $G$ (fictitious cell in place of $W$). The node $c_{B}$ where composition is enforced and the same details presented above still apply here. Here we repeat the immersed node flux computation and do the same with respect to _ghost_ cell $G$.

Our goal is to identify an equation for $c_{G}$ so that it is solved along with the interior points and ensures the same flux as the immersed node. To identify the compatible _ghost_ composition we equate the fluxes by both definitions and solve for $c_{G}$. The following steps repeat what we have seem so far and should be self-explanatory.

```{python}
J_w1 = diffusion_flux(FaceVars.D_b, CellVars.c_P,
                      CellVars.c_B, delta=FvmVars.delta/2)

J_w2 = diffusion_flux(FaceVars.D_g, CellVars.c_P,
                      CellVars.c_G, delta=FvmVars.delta)

tabulate_fv_coefs(J_w1 - J_w2)
```

Care must be taken for interpreting the above result; here $c_{G}$ takes the diagonal position and $c_{P}$ is the first _east_ cell in the first row of the problem's matrix. There is no previous state (no coefficient on $c_{0}$), but a source term based on $c_{B}$ that must be placed on the right-hand side for solution. This is the equation we are looking for to extend the system.

Since this equation has $D_{g}$ as a coefficient, an initial guess for $c_{G}$ is required. The boundary $B$ being the same interface for evaluation of $D_{g}$, for both fluxes to equate one needs to make sure the same diffusivity is evaluated there. Thus we make $D_{b}\equiv{}D_{g}$, what seems physically reasonable but so far not supported by any mathematical argument:

```{python}
c_G_sol = solve(Eq(J_w1, J_w2), CellVars.c_G)[0]

c_G_bis = expand(c_G_sol.subs(FaceVars.D_b, FaceVars.D_g))
c_G_bis
```

This simply says that the composition is linearly extrapolated, with the distances from cell centers to the boundary being used as weighting factors. It ensures the problem is initialized the same as the immersed boundary as we made $D_g=D_b$.

::: {.callout-caution title="Common mistake"}

One could think about solving for $c_G$ and using the result in the standard balance equation, but doing so falls back to the immersed boundary approach. Replacing the solution in `J_w2` simply gets back to the initial point and does not produce one extra equation!

```{python}
J_w = J_w2.subs(CellVars.c_G, c_G_bis)

eq = StandardProblem.full_expression(J_w=J_w, subs_fourier=True)
tabulate_fv_coefs(eq.lhs)
```

:::

## More on boundary conditions

...

## Solution algorithm


Using a segregated solution of non-linear boundaries or immersed nodes:

$$
\begin{bmatrix}
A_{(0)} & A_{E}  & 0      &        &        & \dots  & 0      & 0       \\[6pt]
A_{W}   & A_{P}  & A_{E}  &        &        & \dots  & 0      & 0       \\[6pt]
0       & A_{W}  & A_{P}  & A_{E}  & 0      & \dots  & 0      & 0       \\[6pt]
0       & 0      & \ddots & \ddots & \ddots & \ddots & \vdots & \vdots  \\[6pt]
\vdots  & \vdots & \ddots & \ddots & \ddots & \ddots & 0      & 0       \\[6pt]
0       & 0      & \dots  & 0      & A_{W}  & A_{P}  & A_{E}  & 0       \\[6pt]
0       & 0      & \dots  & 0      & 0      & A_{W}  & A_{P}  & A_{E}   \\[6pt]
0       & 0      & \dots  & 0      & 0      & 0      & A_{W}  & A_{(n)} \\[6pt]
\end{bmatrix}\cdotp
%--------------------------------------
\begin{bmatrix}
c_{(0)}^{\tau}   \\[6pt]
c_{(1)}^{\tau}   \\[6pt]
c_{(2)}^{\tau}   \\[6pt]
c_{(3)}^{\tau}   \\[6pt]
\vdots           \\[6pt]
c_{(N-3)}^{\tau} \\[6pt]
c_{(N-2)}^{\tau} \\[6pt]
c_{(N-1)}^{\tau} \\[6pt]
\end{bmatrix}=
%--------------------------------------
\begin{bmatrix}
c_{(0)}^{0}   \\[6pt]
c_{(1)}^{0}   \\[6pt]
c_{(2)}^{0}   \\[6pt]
c_{(3)}^{0}   \\[6pt]
\vdots           \\[6pt]
c_{(N-3)}^{0} \\[6pt]
c_{(N-2)}^{0} \\[6pt]
c_{(N-1)}^{0} \\[6pt]
\end{bmatrix}+
%--------------------------------------
\begin{bmatrix}
B_{(0)}   \\[6pt]
0         \\[6pt]
0         \\[6pt]
0         \\[6pt]
\vdots    \\[6pt]
0         \\[6pt]
0         \\[6pt]
B_{(N-1)} \\[6pt]
\end{bmatrix}
$$


Integrating boundaries as an extended problem:

$$
\begin{bmatrix}
B_{1}   & B_{2}  & 0      &        &        & \dots  & 0      & 0       \\[6pt]
A_{W}   & A_{P}  & A_{E}  &        &        & \dots  & 0      & 0       \\[6pt]
0       & A_{W}  & A_{P}  & A_{E}  & 0      & \dots  & 0      & 0       \\[6pt]
0       & 0      & \ddots & \ddots & \ddots & \ddots & \vdots & \vdots  \\[6pt]
\vdots  & \vdots & \ddots & \ddots & \ddots & \ddots & 0      & 0       \\[6pt]
0       & 0      & \dots  & 0      & A_{W}  & A_{P}  & A_{E}  & 0       \\[6pt]
0       & 0      & \dots  & 0      & 0      & A_{W}  & A_{P}  & A_{E}   \\[6pt]
0       & 0      & \dots  & 0      & 0      & 0      & C_{2}  & C_{1} \\[6pt]
\end{bmatrix}\cdotp
%--------------------------------------
\begin{bmatrix}
c_{(G)}^{\tau}   \\[6pt]
c_{(0)}^{\tau}   \\[6pt]
c_{(1)}^{\tau}   \\[6pt]
c_{(2)}^{\tau}   \\[6pt]
\vdots           \\[6pt]
c_{(N-2)}^{\tau} \\[6pt]
c_{(N-1)}^{\tau} \\[6pt]
c_{(G)}^{\tau} \\[6pt]
\end{bmatrix}=
%--------------------------------------
\begin{bmatrix}
B_{(0)}^{0}   \\[6pt]
c_{(0)}^{0}   \\[6pt]
c_{(1)}^{0}   \\[6pt]
c_{(2)}^{0}   \\[6pt]
\vdots           \\[6pt]
c_{(N-2)}^{0} \\[6pt]
c_{(N-1)}^{0} \\[6pt]
B_{(n)}^{0} \\[6pt]
\end{bmatrix}
$$

## Python prototype

...
